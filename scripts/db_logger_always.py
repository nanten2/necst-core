#!/usr/bin/env python3

import time
import datetime
import threading
from pathlib import Path
from typing import Any, Dict, Tuple

import necstdb

import rospy
import std_msgs.msg  # noqa: F401

# NODE_NAME = "db_logger_always"


class db_logger_always:
    def __init__(self):
        self.db_dir = Path.home() / "data" / "always"
        self.db_path_date = ""
        self.data_list = []
        self.receive_time_dict = {}
        self.table_dict = {}

        self.th = threading.Thread(target=self.loop)
        self.th.start()

    def regist(self, data: Any) -> None:
        self.data_list.append(data)
        return

    def close_tables(self) -> None:
        tables = self.table_dict
        self.receive_time_dict = {}
        self.table_dict = {}
        [tables[name].close() for name in tables]
        return

    def check_date(self) -> None:
        now = datetime.datetime.now()
        if self.db_path_date != "{0:%Y%m}/{0:%Y%m%d}.necstdb".format(now):
            self.db_path_date = "{0:%Y%m}/{0:%Y%m%d}.necstdb".format(now)
            self.close_tables()
            self.db = necstdb.opendb(self.db_dir / self.db_path_date, mode="w")
        return

    def loop(self) -> None:
        while True:
            if len(self.data_list) == 0:
                self.close_tables()
                if rospy.is_shutdown():
                    break
                time.sleep(0.01)
                continue

            d = self.data_list.pop(0)

            self.check_date()

            if d["topic"] not in self.receive_time_dict:
                self.receive_time_dict[d["topic"]] = d["received_time"]
            elif self.receive_time_dict[d["topic"]] - d["received_time"] < 10:
                continue
            else:
                self.receive_time_dict[d["topic"]] = d["received_time"]

            beam2_topic = [
                "/xffts_board01",
                "/xffts_board02",
                "/xffts_board03",
                "/xffts_board04",
            ]
            if d["topic"] in beam2_topic:
                continue

            table_name = d["topic"].replace("/", "-").strip("-")
            table_data = [d["received_time"]]
            table_info = [{"key": "timestamp", "format": "d", "size": 8}]

            for slot in d["slots"]:
                try:
                    slot, info = self.convert_format(slot)
                except TypeError:
                    continue

                if isinstance(slot["value"], tuple):
                    # MultiArray
                    dlen = len(slot["value"])
                    info["format"] = f"{dlen:d}{info['format']}"
                    info["size"] *= dlen
                    table_data += slot["value"]
                else:
                    table_data += [slot["value"]]

                info["key"] = slot["key"]
                table_info.append(info)

            if table_name not in self.table_dict:
                self.db.create_table(
                    table_name,
                    {
                        "data": table_info,
                        "memo": "generated by db_logger_operation",
                        "version": necstdb.__version__,
                    },
                )
                self.table_dict[table_name] = self.db.open_table(table_name, mode="ab")

            self.table_dict[table_name].append(*table_data)
        return

    @staticmethod
    def convert_format(slot: Dict[str, Any]) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        info = None
        type_dict = {
            "bool": {"format": "c", "size": 1},
            "byte": {"format": "s", "size": None},
            # "char": {},
            "float32": {"format": "f", "size": 4},
            "float64": {"format": "d", "size": 8},
            "int8": {"format": "b", "size": 1},
            "int16": {"format": "h", "size": 2},
            "int32": {"format": "i", "size": 4},
            "int64": {"format": "q", "size": 8},
            "string": {"format": "s", "size": None},
            "uint8": {"format": "B", "size": 1},
            "uint16": {"format": "H", "size": 2},
            "uint32": {"format": "I", "size": 4},
            "uint64": {"format": "Q", "size": 8},
        }
        for type_, info_ in type_dict.items():
            if slot["type"].startswith(type_):
                info = info_

        if info is None:
            raise TypeError(f"Unsupported msg type {slot['type']}.")

        if info["format"] == "s":
            length = len(slot["value"])
            info["format"] = f"{length:d}{info['format']}"
            info["size"] = length
        if (info["format"].find("s") != -1) and isinstance(slot["value"], str):
            slot["value"] = slot["value"].encode()
        if info["format"] == "i":
            slot["value"] = int(slot["value"])

        return slot, info
